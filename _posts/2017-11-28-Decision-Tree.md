---
layout: post
title: 决策树
---
用于分类、回归

## 1.1基础算法
![什么是决策树](https://rudadao.github.io/images/决策树.png)

决策树具有互斥完备性，即样本中每个实例都被有且仅有一条路径覆盖。

决策树是一个if-then规则集合，决策树的生成是一个递归过程。

>* 输入:
>  - 训练集:$D=\{(x_1,y_1),(x_2,y_2)...,(x_m,y_m)\}$
>  - 属性集:$A=\{a_1,a_2,...,a_d\}$
>* 输出：以node为结点的一棵决策树
>* 过程：函数$TreeGenerate(D,A)$
>1. 生成结点node；
>2. **if** D中样本属于同一类别C **then**
>3. 将node标记为C类的叶结点；**return**
>4. **endif**
>5. **if** $A=\emptyset$ **OR** D中的样本点在A中取值相同 **then**
>6.  将node标记为叶结点，类型为D中样本最多的类型；**return**
>7. **endif**
>8. 将A中选择最优划分属性$a_x$
>9. **for** $a_x$中每一个值$a^v_x$ **do**
>10.  为node生成一个分支，令$D_v$表示在$a_x$上取值为$a^v_x$的样本子集；
>11.   **if** $D_v$为空 **then**
>12.    将分支结点标记为叶结点，其类别标记为D中样本最多的类； **return**
>13.   **else**
>14.    以$TreeGenerate(D_v,A\\{a_x\})$为分支结点
>15. **endif**
>14. **endfor**

* 导致递归返回情况
  1. 步骤1-3：结点中样本属于同一类，生成一个叶结点，类型为C类
  2. 步骤5-7：结点中样本因没有属性或者属性取值相同而无法划分，生成一个叶结点，类型为样本最多的类（后验分布）
  3. 步骤11-12：结点中样本为空无法划分，生成一个叶结点，类型为样本D中最多的类（先验分布）
4.


